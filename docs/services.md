# Services üîß

This document describes the **services** provided by `linid-im-front-corelib`.

---

## üîå HTTP Client Service

Provides a singleton Axios instance shared across all modules.

| Function                          | Description                                       |
| --------------------------------- | ------------------------------------------------- |
| [`setHttpClient`](#sethttpclient) | Initializes the shared Axios instance (call once) |
| [`getHttpClient`](#gethttpclient) | Returns the shared Axios instance                 |

---

### `setHttpClient`

Initializes the shared Axios instance to be used by all modules. Should be called once during application bootstrapping.

```typescript
import { setHttpClient } from '@linagora/linid-im-front-corelib';
```

#### Parameters

| Parameter | Type            | Description                      |
| --------- | --------------- | -------------------------------- |
| `client`  | `AxiosInstance` | The Axios instance to be shared. |

#### Returns

No return value.

#### Behavior

1. **Singleton:** Only the first call sets the instance; subsequent calls log a warning and do not overwrite the instance.
2. **Required:** Must be called before any call to `getHttpClient()`.

---

### `getHttpClient`

Retrieves the shared Axios instance initialized by `setHttpClient`.

```typescript
import { getHttpClient } from '@linagora/linid-im-front-corelib';
```

#### Parameters

None.

#### Returns

| Type            | Description                |
| --------------- | -------------------------- |
| `AxiosInstance` | The shared Axios instance. |

#### Behavior

1. **Singleton:** Always returns the same instance set by `setHttpClient`.
2. **Error Handling:** Throws an error if called before initialization.

---

### Usage Examples

#### Basic Usage

```typescript
import { setHttpClient, getHttpClient } from '@linagora/linid-im-front-corelib';
import axios from 'axios';

// Host application bootstrapping
const axiosInstance = axios.create({
  baseURL: '/api',
  timeout: 10000,
});
setHttpClient(axiosInstance);

// In any module
const http = getHttpClient();
http.get('/users').then((response) => {
  // handle response
});
```

---

#### Error Handling

##### Calling `getHttpClient` before initialization

```typescript
import { getHttpClient } from '@linagora/linid-im-front-corelib';

try {
  const http = getHttpClient();
  // Throws: [LinID CoreLib] HTTP client is not initialized. Call setHttpClient() first.
} catch (error) {
  // Handle error
}
```

##### Attempting to re-initialize

```typescript
import { setHttpClient } from '@linagora/linid-im-front-corelib';
import axios from 'axios';

setHttpClient(axios.create());
// Second call logs a warning and does not overwrite the instance
setHttpClient(axios.create());
// Logs: [LinID CoreLib] HTTP client has already been initialized. Re-initialization is ignored.
```

---

### TypeScript Support

The functions are fully typed for use with Axios:

```typescript
import type { AxiosInstance } from 'axios';

const http: AxiosInstance = getHttpClient();
```

---

> The HTTP Client Service ensures all modules share a single, consistent Axios instance for HTTP requests.

### Rules

- ‚úÖ Host calls `setHttpClient()` once during boot
- ‚úÖ Modules use `getHttpClient()` to access the same instance
- ‚ö†Ô∏è Warning logged if re-initialization is attempted
- ‚ùå Error thrown if `getHttpClient()` is called before initialization

---

## üîó Federation Service

Provides helpers wrapping **Module Federation (enhanced runtime)** functionalities and enforcing a consistent initialization and loading model across the application.

This service centralizes access to the Module Federation instance and exposes high-level helpers for loading federated Vue components.

| Function                                      | Description                                                  |
| --------------------------------------------- | ------------------------------------------------------------ |
| [`setModuleFederation`](#setmodulefederation) | Registers the Module Federation instance from host           |
| [`getModuleFederation`](#getmodulefederation) | Returns the active Module Federation instance from host      |
| [`loadAsyncComponent`](#loadasynccomponent)   | Loads a remote Vue component from a Module Federation remote |

---

### üß† Runtime Initialization Model

This library relies on a **single Module Federation instance** generated by Vite in the host during build, shared across all consumers.

The Module Federation instance from host **must be retrieved and registered once during application bootstrap** using `getInstance()` (from the `@module-federation/enhanced/runtime` library) and `setModuleFederation()`. All subsequent federation operations depend on this instance.

Failure to initialize the runtime before loading federated modules will result in a runtime error.

---

### `setModuleFederation`

Registers the active Module Federation instance from host for the application.

This function **must be called exactly once**, typically during application startup. The instance should be retrieved using the `getInstance` method from the `@module-federation/enhanced/runtime` library.

Subsequent calls are ignored to prevent accidental re-initialization.

#### Signature

```ts
setModuleFederation(instance:ModuleFederation): void
```

#### Parameters

| Parameter  | Type               | Description                               |
| ---------- | ------------------ | ----------------------------------------- |
| `instance` | `ModuleFederation` | An initialized Module Federation instance |

#### Behavior

- Registers the active Module Federation instance globally
- Ignores re-initialization attempts and logs a warning
- Required before calling `getModuleFederation()` or `loadAsyncComponent()`

---

### `getModuleFederation`

Returns the active Module Federation instance.

This accessor enforces correct initialization order.

#### Signature

```ts
getModuleFederation(): ModuleFederation;
```

#### Throws

- `Error` if the runtime has not been initialized via `setModuleFederation()`

---

### `loadAsyncComponent`

Loads a remote Vue component from a Module Federation remote using the **enhanced runtime**.

This helper wraps:

- Vue‚Äôs `defineAsyncComponent`
- The Module Federation runtime‚Äôs `loadRemote()` method

It provides a safe, declarative way to consume federated Vue components.

```ts
import { loadAsyncComponent } from '@linagora/linid-im-front-corelib';
```

---

#### Parameters

| Parameter | Type     | Description                                                                                          |
| --------- | -------- | ---------------------------------------------------------------------------------------------------- |
| `plugin`  | `string` | Remote module identifier in the format `remoteName/modulePath`<br/>Example: `'myRemote/MyComponent'` |

---

#### Returns

Returns a **Vue async component** that can be:

- used in templates via `<component :is="...">`
- rendered programmatically
- lazily resolved at runtime

---

#### Behavior

1. **Runtime dependency**
   Requires the Module Federation instance to be retrieved via `getInstance()` and registered with `setModuleFederation()`

2. **Lazy loading**
   The remote module is fetched only when the component is rendered

3. **ESM compliance**
   Expects the remote module to be an ESM namespace object exposing a `default` export

4. **Error handling**
   Throws an error if:
   - the remote module is `null` or `undefined`
   - the module does not expose a `default` export

5. **Type safety**
   Expects the remote module to follow the `FederatedModule<T>` contract

---

#### Usage Examples

##### Application Bootstrap

```ts
import { getInstance } from '@module-federation/enhanced/runtime';
import { setModuleFederation } from '@linagora/linid-im-front-corelib';

setModuleFederation(getInstance());
```

---

##### Basic Usage

```vue
<template>
  <component :is="remoteComponent" />
</template>

<script setup lang="ts">
import { loadAsyncComponent } from '@linagora/linid-im-front-corelib';
import { ref } from 'vue';
import type { Component } from 'vue';

const remoteComponent = ref<Component | null>(null);

remoteComponent.value = loadAsyncComponent('myRemote/HeaderWidget');
</script>
```

---

##### Dynamic Component Loading

```vue
<template>
  <component
    v-for="plugin in plugins"
    :key="plugin"
    :is="loadAsyncComponent(plugin)"
  />
</template>

<script setup lang="ts">
import { loadAsyncComponent } from '@linagora/linid-im-front-corelib';

const plugins = ['remote1/ComponentA', 'remote2/ComponentB'];
</script>
```

---

#### Error Handling

##### Module Not Found

If the remote module cannot be loaded:

```typescript
const component.value = loadAsyncComponent('invalidRemote/Component');
// Throws: Error loading remote module
```

##### Missing Default Export

If the module doesn't export a default component:

```typescript
// Remote module exports: export { MyComponent }
const component.value = loadAsyncComponent('myRemote/MyComponent');
// Throws: Failed to load component from myRemote/MyComponent
```

**Solution:** Ensure your remote module exports a default component:

```vue
<!-- ‚úÖ Correct - remote module (.vue file) -->
<template>
  <div>My Component</div>
</template>

<script setup lang="ts">
// Default export automatic with <script setup>
// Nothing special to do!
</script>
```

**Alternative with Options API:**

```vue
<!-- ‚úÖ Correct - remote module (.vue file) -->
<template>
  <div>My Component</div>
</template>

<script lang="ts">
import { defineComponent } from 'vue';

export default defineComponent({
  name: 'MyComponent',
  // ...
});
</script>
```

**‚ùå Wrong - TypeScript/JavaScript file (not .vue):**

```typescript
// In a .ts file (not .vue)
// ‚ùå Named export only - doesn't work with loadAsyncComponent
export const MyComponent = defineComponent({
  // ...
});

// ‚úÖ Correct - default export
export default defineComponent({
  name: 'MyComponent',
  // ...
});
```

---

#### TypeScript Support

##### Remote Module Structure

The function expects remotes to follow this structure:

```typescript
/**
 * ESM namespace object returned when loading a remote component through
 * Module Federation (for example via `loadRemote`).
 *
 * In a Vite + native ESM environment, federated modules are not auto-unwrapped:
 * the effective export is exposed on the `default` property of the namespace.
 */
interface FederatedModule<Component> {
  /**
   * The default exported Vue component.
   */
  default: Component;
}
```

##### Type Inference

The returned component is fully typed as a Vue `Component`:

```typescript
import type { Component } from 'vue';

const myComponent: Component = loadAsyncComponent('remote/Component');
```

---

### ‚ö†Ô∏è Common Errors

| Error Message                            | Cause                                  |
| ---------------------------------------- | -------------------------------------- |
| `Module Federation is not initialized`   | `setModuleFederation()` was not called |
| `Failed to load component from <plugin>` | Missing or invalid `default` export    |

---

### üßæ Summary

- Module Federation runtime is **explicitly managed**
- Initialization is **mandatory and centralized**
- `loadAsyncComponent` provides a safe abstraction over `loadRemote`
- All federated modules **must export a default value**

This design guarantees predictable behavior, testability, and runtime safety across all federated front-end modules.

---

## üóÑÔ∏è Entity Service

The **Entity Service** provides a standardized CRUD abstraction for backend entity management. Each operation automatically resolves the correct backend endpoint using the module‚Äôs `instanceId` and its registered configuration.

This service builds on top of the HTTP Client Service and the Module Host Configuration Service.

| Function                                | Description                            |
| --------------------------------------- | -------------------------------------- |
| [`saveEntity`](#saveentity)             | Creates a new entity on the backend    |
| [`updateEntity`](#updateentity)         | Updates an existing entity             |
| [`getEntities`](#getentities)           | Retrieves a paginated list of entities |
| [`getEntityById`](#getentitybyid)       | Retrieves a single entity by ID        |
| [`deleteEntityById`](#deleteentitybyid) | Deletes a single entity by ID          |

---

### `saveEntity`

Creates and persists a new entity using the backend API associated with the module instance.

#### Parameters

| Parameter    | Type     | Description                       |
| ------------ | -------- | --------------------------------- |
| `instanceId` | `string` | Identifier of the module instance |
| `record`     | `T`      | Entity data to create             |

#### Returns

| Type | Description                           |
| ---- | ------------------------------------- |
| `Y`  | The created entity returned by server |

#### Behavior

1. Automatically resolves the backend endpoint through `getModuleHostConfiguration`
2. Issues a `POST` request with the entity payload
3. Returns the deserialized response body

#### Example

```ts
const created = await saveEntity<UserInput, User>('users', newUser);
```

---

### `updateEntity`

Updates an existing entity in the backend.

#### Parameters

| Parameter    | Type     | Description                       |
| ------------ | -------- | --------------------------------- |
| `instanceId` | `string` | Identifier of the module instance |
| `entityId`   | `string` | The ID of the entity to update    |
| `record`     | `T`      | New data to update the entity     |

#### Returns

| Type | Description                           |
| ---- | ------------------------------------- |
| `Y`  | The updated entity returned by server |

---

### `getEntities`

Retrieves a paginated list of entities.

#### Parameters

| Parameter    | Type          | Description                       |
| ------------ | ------------- | --------------------------------- |
| `instanceId` | `string`      | Identifier of the module instance |
| `filters`    | `QueryFilter` | Filters to apply to the search    |
| `pagination` | `Pagination`  | Pagination parameters             |

#### Returns

| Type      | Description                           |
| --------- | ------------------------------------- |
| `Page<T>` | A page object containing entity items |

---

### `getEntityById`

Fetches a single entity by its unique identifier.

#### Parameters

| Parameter    | Type     | Description                       |
| ------------ | -------- | --------------------------------- |
| `instanceId` | `string` | Identifier of the module instance |
| `entityId`   | `string` | ID of the entity to retrieve      |

#### Returns

| Type | Description                  |
| ---- | ---------------------------- |
| `T`  | The retrieved entity content |

---

### `deleteEntityById`

Deletes a single entity by ID.

#### Parameters

| Parameter    | Type     | Description                       |
| ------------ | -------- | --------------------------------- |
| `instanceId` | `string` | Identifier of the module instance |
| `entityId`   | `string` | ID of the entity to delete        |

#### Returns

`void`

#### Behavior

1. Resolves endpoint from module configuration
2. Performs a `DELETE` HTTP request
3. Returns an empty Promise

---

### Usage Example

```ts
// Create
await saveEntity('users', { name: 'Alice' });

// Update
await updateEntity('users', '42', { name: 'Alice Cooper' });

// Retrieve paginated list
const page = await getEntities<User>(
  'users',
  { search: 'alice' },
  { page: 0, size: 20 }
);

// Retrieve by ID
const user = await getEntityById<User>('users', '42');

// Delete
await deleteEntityById('users', '42');
```

---

This service provides a unified, module-aware way to manage backend CRUD operations while relying on shared configuration and HTTP client infrastructure.

---

## üçç Pinia Store Service

Provides a singleton Pinia store instance shared across all modules, ensuring a unified state management context for the entire application.

| Function                          | Description                                    |
| --------------------------------- | ---------------------------------------------- |
| [`setPiniaStore`](#setpiniastore) | Initializes the shared Pinia store (call once) |
| [`getPiniaStore`](#getpiniastore) | Returns the shared Pinia store instance        |

---

### `setPiniaStore`

Initializes the shared Pinia store instance to be used by all modules. Should be called **once** during application bootstrapping by the host application.

```typescript
import { setPiniaStore } from '@linagora/linid-im-front-corelib';
import { createPinia } from 'pinia';

const pinia = createPinia();
setPiniaStore(pinia);
```

#### Parameters

| Parameter | Type    | Description                      |
| --------- | ------- | -------------------------------- |
| `store`   | `Pinia` | The Pinia instance to be shared. |

#### Returns

No return value.

#### Behavior

1. **Singleton:** Only the first call sets the instance; subsequent calls log a warning and do not overwrite the instance.
2. **Required:** Must be called before any call to `getPiniaStore()`.

#### Error Handling

- If called more than once, logs a warning:  
  `[LinID CoreLib] Pinia store has already been initialized. Re-initialization is ignored.`

---

### `getPiniaStore`

Retrieves the shared Pinia store instance initialized by `setPiniaStore`.

```typescript
import { getPiniaStore } from '@linagora/linid-im-front-corelib';

const pinia = getPiniaStore();
```

#### Parameters

None.

#### Returns

| Type    | Description                |
| ------- | -------------------------- |
| `Pinia` | The shared Pinia instance. |

#### Behavior

1. **Singleton:** Always returns the same instance set by `setPiniaStore`.
2. **Error Handling:** Throws an error if called before initialization.

#### Error Handling

- If called before initialization, throws:  
  `[LinID CoreLib] Pinia store is not initialized. Call setPiniaStore() first.`

---

### Usage in Store Definitions

All Pinia stores defined in this library (such as `linidConfigurationStore` and `linidZoneStore`) internally use `getPiniaStore()` to ensure they are attached to the singleton Pinia instance created by the host application.

When defining a new store (either in the host or a module), you should follow the same architecture:

1. **Export a composable function** (e.g., `useMyStore`) that calls your internal store definition with the Pinia instance returned by `getPiniaStore()`.
2. **Do not call `defineStore` directly in the host/module**‚Äîalways use the exported composable to ensure the correct Pinia context.

#### Example Pattern

```typescript
// myStore.ts
import { defineStore } from 'pinia';
import { getPiniaStore } from '@linagora/linid-im-front-corelib';

export const useMyStore = () => _useMyStore(getPiniaStore());

const _useMyStore = defineStore('myStore', {
  // state, getters, actions...
});
```

This ensures your store is always registered on the singleton Pinia instance shared across all modules.

---

### Usage Examples

#### Basic Usage

```typescript
import { setPiniaStore, getPiniaStore } from '@linagora/linid-im-front-corelib';
import { createPinia } from 'pinia';

// Host application bootstrapping
const pinia = createPinia();
setPiniaStore(pinia);

// In any module
const store = getPiniaStore();
```

#### Using a Store

```typescript
import { useLinidConfigurationStore } from '@linagora/linid-im-front-corelib';

const configStore = useLinidConfigurationStore();
```

#### Defining and using a Custom Store in a Module

```typescript
import { defineStore } from 'pinia';
import { getPiniaStore } from '@linagora/linid-im-front-corelib';

export const useCustomStore = () => _useCustomStore(getPiniaStore());

const _useCustomStore = defineStore('customStore', {
  // state, getters, actions...
});
```

Then use it in your module:

```typescript
import { useCustomStore } from './customStore';

const store = useCustomStore();
```

---

### TypeScript Support

The functions are fully typed for use with Pinia:

```typescript
import type { Pinia } from 'pinia';

const pinia: Pinia = getPiniaStore();
```

---

> The Pinia Store Service ensures all modules share a single, consistent Pinia instance for state management.

### Rules

- ‚úÖ Host calls `setPiniaStore()` once during boot
- ‚úÖ Modules use `getPiniaStore()` to access the same instance
- ‚úÖ All stores must be defined using a composable that injects the singleton Pinia instance
- ‚ö†Ô∏è Warning logged if re-initialization is attempted
- ‚ùå Error thrown if `getPiniaStore()` is called before initialization

---

> Additional services will be added as new features are implemented in the library.
